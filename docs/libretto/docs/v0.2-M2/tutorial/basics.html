<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.0 + Helium Theme" />
    <title>Libretto Basics</title>
    
    
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    
    <link rel="stylesheet" type="text/css" href="helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="helium/laika-helium.css" />
    <script src="helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>
  
      <a class="text-link" href="https://github.com/TomasMikula/libretto">GitHub</a>
      
      <span class="row"></span>
      
    </header>

    <nav id="sidebar">

      <ul class="nav-list">
        <li class="level1 active"><a href="#">Libretto Basics</a></li>
      </ul>
      
    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">Libretto Basics</a></p>
        
        <ul class="nav-list">
          <li class="level1"><a href="#setup">Setup</a></li>
          <li class="level2"><a href="#sbt-project-setup">sbt project setup</a></li>
          <li class="level2"><a href="#imports">Imports</a></li>
          <li class="level1"><a href="#building-blocks">Building blocks</a></li>
          <li class="level1"><a href="#maximum-concurrency">Maximum concurrency</a></li>
          <li class="level1"><a href="#sequential-composition">Sequential composition</a></li>
          <li class="level1"><a href="#parallel-composition">Parallel composition</a></li>
          <li class="level1"><a href="#scala-notation">Scala notation</a></li>
          <li class="level1"><a href="#the-identity-component">The identity component</a></li>
          <li class="level1"><a href="#associativity-of">Associativity of ⊗</a></li>
          <li class="level1"><a href="#symmetry-of">Symmetry of ⊗</a></li>
          <li class="level1"><a href="#the-no-flow-port-one">The no-flow port, <code>One</code></a></li>
          <li class="level1"><a href="#signals">Signals</a></li>
          <li class="level2"><a href="#immediate-signals">Immediate signals</a></li>
          <li class="level2"><a href="#non-dismissible-signals">Non-dismissible signals</a></li>
          <li class="level2"><a href="#dismissible-signals">Dismissible signals</a></li>
          <li class="level2"><a href="#forking-and-joining-signals">Forking and joining signals</a></li>
          <li class="level2"><a href="#inverting-signals">Inverting signals</a></li>
          <li class="level1"><a href="#either">Either (⊕)</a></li>
          <li class="level1"><a href="#choice">Choice (&amp;)</a></li>
          <li class="level1"><a href="#distributivity-of-over">Distributivity of ⊗ over ⊕</a></li>
          <li class="level1"><a href="#co-distributivity-of-over">Co-distributivity of ⊗ over &amp;</a></li>
          <li class="level1"><a href="#linearity-and-point-free-style">Linearity and point-free style</a></li>
          <li class="level1"><a href="#recursion">Recursion</a></li>
          <li class="level2"><a href="#recursive-types">Recursive types</a></li>
          <li class="level2"><a href="#recursive-functions">Recursive functions</a></li>
          <li class="level1"><a href="#racing">Racing</a></li>
          <li class="level2"><a href="#racing-is-a-source-of-non-determinism">Racing is a source of non-determinism</a></li>
          <li class="level1"><a href="#using-scala-values-and-functions">Using Scala values and functions</a></li>
          <li class="level1"><a href="#equality-of-libretto-programs">Equality of Libretto programs</a></li>
        </ul>
        
        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="libretto-basics" class="title">Libretto Basics</h1>
        <p>A concurrent program in Libretto DSL is a <em>pure value</em> of a certain type (such as the type <code>Done -⚬ Done</code> or
        <code>Done -⚬ Val[String]</code>).
        Such a value is a mere <em>description,</em> or <em>blueprint,</em> of a program to be executed.
        The blueprint can then be passed to an interpreter for execution.</p>
        <p>Programmer&#39;s task is then to write Scala code that first assembles a blueprint and then
        passes is to an interpreter for execution. We thus think of run-time as split into
        <strong>assembly time</strong> and <strong>execution time</strong>.</p>
        
        <h2 id="setup" class="section"><a class="anchor-link left" href="#setup"><i class="icofont-laika">&#xef71;</i></a>Setup</h2>
        
        <h3 id="sbt-project-setup" class="section"><a class="anchor-link left" href="#sbt-project-setup"><i class="icofont-laika">&#xef71;</i></a>sbt project setup</h3>
        <p>You will need Scala 3 in order to use Libretto. Scala 3 requires a fairly recent version of sbt. Specify the sbt version in your <code>project/build.properties</code> file:</p>
        <pre class="keep-together pdf epub"><code class="properties">sbt.version=1.5.5</code></pre>
        <p>In your <code>build.sbt</code>, set the Scala version to Scala 3 and add the dependency on Libretto:</p>
        <pre class="keep-together pdf epub"><code class="sbt">scalaVersion := &quot;3.0.2&quot;

libraryDependencies += &quot;com.github.tomasmikula&quot; %% &quot;libretto&quot; % &quot;0.1.5&quot;</code></pre>
        <p>Check <a href="https://search.maven.org/search?q=com.github.tomasmikula%20libretto">search.maven.org</a> for the latest version of
        Libretto.</p>
        
        <h3 id="imports" class="section"><a class="anchor-link left" href="#imports"><i class="icofont-laika">&#xef71;</i></a>Imports</h3>
        <p>The code snippets below use these imports:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">libretto</span><span>.</span><span class="type-name">StarterKit</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span></code></pre>
        
        <h2 id="building-blocks" class="section"><a class="anchor-link left" href="#building-blocks"><i class="icofont-laika">&#xef71;</i></a>Building blocks</h2>
        <p>Libretto programs are composed of <strong>components</strong> with typed <strong>in-ports</strong> and <strong>out-ports</strong>,
        such as this one:</p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘          ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>We draw in-ports on the left and out-ports on the right.</p>
        <p>The in-ports and out-ports define the <em>interface</em> of a component.</p>
        <p>We can think of a component as a part of a system that runs autonomously and communicates with the rest of the system
        through its in-ports and out-ports.</p>
        <p>☝️ Do <em>not</em> assume that through in-ports information flows into the component and through out-ports information flows out
        of the component. That may or may not be the case. In general, information may flow in either direction or even in both
        directions through an in-port as well as through an out-port. However, the distinction between in-ports and out-ports
        is important for composition, see below.</p>
        
        <h2 id="maximum-concurrency" class="section"><a class="anchor-link left" href="#maximum-concurrency"><i class="icofont-laika">&#xef71;</i></a>Maximum concurrency</h2>
        <p>We can be sure that event <em>e&lt;sub&gt;2&lt;/sub&gt;</em> happens after event <em>e&lt;sub&gt;1&lt;/sub&gt;</em> only if <em>e&lt;sub&gt;2&lt;/sub&gt;</em>
        <strong>causally depends</strong> on <em>e&lt;sub&gt;1&lt;/sub&gt;</em>. If there is no causal dependence between <em>e&lt;sub&gt;1&lt;/sub&gt;</em> and <em>e&lt;sub&gt;2&lt;/sub&gt;</em>,
        then they happen concurrently (☝️ but not necessarily in parallel).</p>
        <p>This is different from what most people are used to. It usually takes some work to make things happen concurrently.
        In Libretto, it takes some work to make things happen sequentially if there is no natural causal dependence between
        them.</p>
        <p>As we proceed, we will get an idea of what does and what does not introduce a causal dependence.</p>
        
        <h2 id="sequential-composition" class="section"><a class="anchor-link left" href="#sequential-composition"><i class="icofont-laika">&#xef71;</i></a>Sequential composition</h2>
        <p>We can connect an out-port to an in-port (but not to another out-port) of the same type on another component.
        For example, these two components <code>f</code> and <code>g</code></p>
        <pre><code>┏━━━━━━━━━━━━┓    ┏━━━━━━━━━━━━┓
┞─┐          ┞─┐  ┞─┐          ┞─┐
╎A│    f     ╎B│  ╎B│    g     ╎C│
┟─┘          ┟─┘  ┟─┘          ┟─┘
┗━━━━━━━━━━━━┛    ┗━━━━━━━━━━━━┛</code></pre>
        <p>can be composed into a composite component <code>g ⚬ f</code></p>
        <pre><code>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┞─┐                            ┞─┐
╎A│           g ⚬ f            ╎C│
┟─┘                            ┟─┘
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Although we call it <em>sequential</em> composition, do <em>not</em> assume that<code>g</code> takes place &quot;after&quot; <code>f</code>, in a temporal or
        causal sense. There may or may not be causal dependence in either direction, or even both directions simultaneously.
        We would need know the interface type <code>B</code> and possibly the inner
        workings of the components to make judgments about causal dependence. In general, processing can take place in <code>g</code> even
        before any information passes through the <code>B</code> interface.</p>
        
        <h2 id="parallel-composition" class="section"><a class="anchor-link left" href="#parallel-composition"><i class="icofont-laika">&#xef71;</i></a>Parallel composition</h2>
        <p>Any two components <code>f</code>, <code>g</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│    f     ╎C│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛
┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎B│    g     ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>can be put alongside each other (parallel to each other) to form their <em>parallel composition</em> <em>f ⊗ g</em></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘  f ⊗ g   ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        
        <h2 id="scala-notation" class="section"><a class="anchor-link left" href="#scala-notation"><i class="icofont-laika">&#xef71;</i></a>Scala notation</h2>
        <p>The graphical notation is useful for a human, but eventually we have to express our Libretto program by means of the
        host language, Scala.</p>
        <p>A component <code>f</code> with one in-port of type <code>A</code> and one out-port of type <code>B</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│    f     ╎B│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>is a value <code>f</code> of type <code>A -⚬ B</code>.</p>
        <p>The funny arrow-like symbol, <code>-⚬</code>, also called a <em>lollipop</em>, is borrowed from linear logic where it denotes <em>linear
        implication</em> and in Libretto we similarly call it a <em>linear function.</em> We will also call it simply an <em>arrow</em> if there
        is no risk of confusion with other things called arrows. So we use the terms component, linear function and arrow as
        synonyms.</p>
        <p>☝️ Although we call <code>-⚬</code> a linear <em>function,</em> some intuitions one might have about Scala functions (<code>=&gt;</code>) do not
        transfer to <code>-⚬</code>. With a Scala function, there is nothing going on inside it until we pass all the inputs to it.
        Once we get the output (and we get the whole output all at once), the Scala function is done. Remember, however,
        that Libretto&#39;s linear function is a component, a part of the system that runs on its own and perhaps communicates
        with its environment through the ports.
        However, composition of Libretto&#39;s linear functions works just like composition of Scala functions.</p>
        <p>In Scala, we model multiple in-ports as a single in-port of a composite type, and similarly for out-ports.
        As an example, a component <code>f</code> with two in-ports of types <code>A</code> and <code>B</code> and two out-ports of types <code>C</code> and <code>D</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘    f     ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>is represented as a value <code>f: (A ⊗ B) -⚬ (C ⊗ D)</code>.
        The expression <em>X ⊗ Y</em> represents a <strong>concurrent pair</strong> of <em>X</em> and <em>Y</em>, sometimes referred to simply as <em>X times Y</em>.
        It is also called a <em>tensor product</em> or a <em>monoidal product</em> (of a monoidal category).</p>
        <p>Because the ⊗ symbol is usually not very intelligible in monospace fonts (e.g. hardly distinguishable from ⊕, compare
        <code>⊗</code> vs. <code>⊕</code>), in code we usually use <code>|*|</code> for the concurrent pair.
        The above component is then <code>f: (A |*| B) -⚬ (C |*| D)</code>.</p>
        <p>The operator for sequential composition introduced above is <code>andThen</code> (again, do not assume any temporal meaning):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">andThen</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span></code></pre>
        <p>There are syntactic extensions that let us write</p>
        <ul>
          <li><code>f &gt; g</code> instead of <code>andThen(f, g)</code>,</li>
          <li><code>f ⚬ g</code> (read <em>f after g</em>) instead of <code>andThen(g, f)</code>.</li>
        </ul>
        <p>The operator for parallel composition is <code>par</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">par</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>, </span><span class="type-name">D</span><span>](
  </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>,
  </span><span class="identifier">g</span><span>: </span><span class="type-name">C</span><span> -⚬ </span><span class="type-name">D</span><span>,
): (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) -⚬ (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">D</span><span>)</span></code></pre>
        
        <h2 id="the-identity-component" class="section"><a class="anchor-link left" href="#the-identity-component"><i class="icofont-laika">&#xef71;</i></a>The identity component</h2>
        <p>For any type <code>A</code> there is an <em>identity</em> function (component)</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┓
 *  ┞─┐          ┞─┐
 *  ╎A│  id[A]   ╎A│
 *  ┟─┘          ┟─┘
 *  ┗━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">id</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">A</span></code></pre>
        <p>All it does is relay information from in-ports to out-ports and from out-ports to in-ports, unchanged.
        It can be thought of as an extension cord. It is not useful by itself, but it comes in handy in compositions.</p>
        <p>As an example, say that we want to connect the second out-port of <code>f: A -⚬ (B |*| C)</code> to the in-port of
        <code>g: C -⚬ D</code>. In the graphical notation, it is tempting to just put them next to each other like this:</p>
        <pre><code>┏━━━━━━━━━━━┓
┃           ┞─┐
┃           ╎B│
┞─┐         ┟─┘
╎A│   f     ┣━━━━━━━━━━━┓
┟─┘         ┞─┐         ┞─┐
┃           ╎C│    g    ╎D│
┃           ┟─┘         ┟─┘
┗━━━━━━━━━━━┻━━━━━━━━━━━┛</code></pre>
        <p>But how would we do it in Scala using only what we already know, namely sequential and parallel composition?
        We can first place <code>id[B]</code> parallel to <code>g</code>, obtaining</p>
        <pre><code>                    ┏━━━━━━━━━━━┓
                    ┞─┐         ┞─┐
                    ╎B│  id[B]  ╎B│
                    ┟─┘         ┟─┘
par(id[B], g)   =   ┠╌╌╌╌╌╌╌╌╌╌╌┨
                    ┞─┐         ┞─┐
                    ╎C│    g    ╎D│
                    ┟─┘         ┟─┘
                    ┗━━━━━━━━━━━┛</code></pre>
        <p>and then place it after <code>f</code>, obtaining</p>
        <pre><code>                        ┏━━━━━━━━━━━┯━━━━━━━━━━━┓
                        ┃           ├─┐         ┞─┐
                        ┃           ╎B│  id[B]  ╎B│
                        ┞─┐         ├─┘         ┟─┘
f &gt; par(id[B], g)   =   ╎A│   f     ├╌╌╌╌╌╌╌╌╌╌╌┨
                        ┟─┘         ├─┐         ┞─┐
                        ┃           ╎C│    g    ╎D│
                        ┃           ├─┘         ┟─┘
                        ┗━━━━━━━━━━━┷━━━━━━━━━━━┛</code></pre>
        
        <h2 id="associativity-of" class="section"><a class="anchor-link left" href="#associativity-of"><i class="icofont-laika">&#xef71;</i></a>Associativity of ⊗</h2>
        <p>If we are designing a component with more than two in-ports or out-ports, such as this one,</p>
        <pre><code>┏━━━━━━━━━━━━┓
┃            ┞─┐
┃            ╎B│
┃            ┟─┘
┞─┐          ┞─┐
╎A│    f     ╎C│
┟─┘          ┟─┘
┃            ┞─┐
┃            ╎D│
┃            ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>we need to choose how to group the ports using ⊗ (<code>|*|</code>) in the Scala representation.
        For the above component, there are two possibilities:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">f1</span><span>: </span><span class="type-name">A</span><span> -⚬ ((</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>) |*| </span><span class="type-name">D</span><span>)
</span><span class="identifier">f2</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>))</span></code></pre>
        <p>Sometimes one way is more natural than the other, but often it is an arbitrary choice.
        We need not worry about it too much, though, because the grouping does not matter:
        we can always regroup the ports using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">assocLR</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>, </span><span class="type-name">Z</span><span>]: ((</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) |*| </span><span class="type-name">Z</span><span>) -⚬ (</span><span class="type-name">X</span><span> |*| (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">Z</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">assocRL</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>, </span><span class="type-name">Z</span><span>]: (</span><span class="type-name">X</span><span> |*| (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">Z</span><span>)) -⚬ ((</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) |*| </span><span class="type-name">Z</span><span>)</span></code></pre>
        <pre><code>┏━━━━━━━━━━━━━━━━┓             ┏━━━━━━━━━━━━━━━━┓
┞─┐              ┞─┐           ┞─┐              ┞─┐
╎X│              ╎X│           ╎X│              ╎X│
╎⊗│              ┟─┘           ┟─┘              ╎⊗│
╎Y│   assocLR    ┞─┐           ┞─┐   assocRL    ╎Y│
┟─┘              ╎Y│           ╎Y│              ┟─┘
┞─┐              ╎⊗│           ╎⊗│              ┞─┐
╎Z│              ╎Z│           ╎Z│              ╎Z│
┟─┘              ┟─┘           ┟─┘              ┟─┘
┗━━━━━━━━━━━━━━━━┛             ┗━━━━━━━━━━━━━━━━┛</code></pre>
        <p>Thus, if we have</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">f1</span><span>: </span><span class="type-name">A</span><span> -⚬ ((</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>) |*| </span><span class="type-name">D</span><span>) =
  ???</span></code></pre>
        <p>we can always get</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">f2</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) =
  </span><span class="identifier">f1</span><span> &gt; </span><span class="identifier">assocLR</span></code></pre>
        
        <h2 id="symmetry-of" class="section"><a class="anchor-link left" href="#symmetry-of"><i class="icofont-laika">&#xef71;</i></a>Symmetry of ⊗</h2>
        <p>The relative order of ports does not matter, either.</p>
        <p>If, for example, we have a component</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━━━━┓
 *  ┞─┐              ┞─┐
 *  ╎A│              ╎C│
 *  ┟─┘              ┟─┘
 *  ┃       g1       ┞─┐
 *  ┃                ╎D│
 *  ┞─┐              ╎⊗│
 *  ╎B│              ╎E│
 *  ┟─┘              ┟─┘
 *  ┗━━━━━━━━━━━━━━━━┛
 *
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g1</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ (</span><span class="type-name">C</span><span> |*| (</span><span class="type-name">D</span><span> |*| </span><span class="type-name">E</span><span>)) =
  ???</span></code></pre>
        <p>and need</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">g2</span><span>: (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ ((</span><span class="type-name">E</span><span> |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">C</span><span>) =
  ???</span></code></pre>
        <p>we can easily get it using <code>swap</code></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━━━━┓
 *  ┞─┐              ┞─┐
 *  ╎X│              ╎Y│
 *  ┟─┘  swap[X,Y]   ┟─┘
 *  ┞─┐              ┞─┐
 *  ╎Y│              ╎X│
 *  ┟─┘              ┟─┘
 *  ┗━━━━━━━━━━━━━━━━┛
 *
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">swap</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>]: (</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) -⚬ (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">X</span><span>)</span></code></pre>
        <p>like this</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
 *  ┞─┐          ├─┐              ├─┐              ├─┐             ┞─┐
 *  ╎B│          ╎A│              ╎C│              ╎D│             ╎E│
 *  ┟─┘          ├─┘              ├─┘              ╎⊗│  swap[D, E] ╎⊗│
 *  ┃            ╎                ╎ swap[C, D ⊗ E] ╎E│             ╎D│
 *  ┃ swap[B, A] ╎       g1       ├─┐              ├─┘             ┟─┘
 *  ┃            ╎                ╎D│              ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
 *  ┞─┐          ├─┐              ╎⊗│              ├─┐             ┞─┐
 *  ╎A│          ╎B│              ╎E│              ╎C│    id[C]    ╎C│
 *  ┟─┘          ├─┘              ├─┘              ├─┘             ┟─┘
 *  ┗━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g2</span><span>: (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ ((</span><span class="type-name">E</span><span> |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">swap</span><span>[</span><span class="type-name">B</span><span>, </span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">g1</span><span> &gt; </span><span class="identifier">swap</span><span>[</span><span class="type-name">C</span><span>, </span><span class="type-name">D</span><span> |*| </span><span class="type-name">E</span><span>] &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">swap</span><span>[</span><span class="type-name">D</span><span>, </span><span class="type-name">E</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">C</span><span>])</span></code></pre>
        
        <h2 id="the-no-flow-port-one" class="section"><a class="anchor-link left" href="#the-no-flow-port-one"><i class="icofont-laika">&#xef71;</i></a>The no-flow port, <code>One</code></h2>
        <p>Sometimes we want a component with no in-ports or no out-ports, such as these ones</p>
        <pre><code>┏━━━━━━━━━━━━┓            ┏━━━━━━━━━━━━┓
┃            ┞─┐          ┞─┐          ┃
┃      f     ╎A│          ╎B│    g     ┃
┃            ┟─┘          ┟─┘          ┃
┗━━━━━━━━━━━━┛            ┗━━━━━━━━━━━━┛</code></pre>
        <p>In Scala representation, however, we have to specify the type of in-port and the type of outport.
        There is a special fake port type, <code>One</code>, through which there is no flow of information in either direction.</p>
        <p>We can declare the above two components as</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">One</span></code></pre>
        <p>In graphical notation, we omit <code>One</code>-typed ports if they do not add any value (such as above), but keep them if they do
        (such as below).</p>
        <p>We can freely add and remove <code>One</code> to/from in-ports and/or out-ports using the following primitives:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━┓           ┏━━━━━━━━━━━━━━━━┓
//  ┃             ┞───┐       ┞───┐            ┃
//  ┃             ╎One│       ╎One│            ┃
//  ┃ introFst[A] ┟───┘       ┟───┘ elimFst[A] ┃
//  ┞───┐         ┞───┐       ┞───┐            ┞───┐
//  ╎ A │         ╎ A │       ╎ A │            ╎ A │
//  ┟───┘         ┟───┘       ┟───┘            ┟───┘
//  ┗━━━━━━━━━━━━━┛           ┗━━━━━━━━━━━━━━━━┛
//
//  ┏━━━━━━━━━━━━━┓           ┏━━━━━━━━━━━━━━━━┓
//  ┞───┐         ┞───┐       ┞───┐            ┞───┐
//  ╎ A │         ╎ A │       ╎ A │            ╎ A │
//  ┟───┘         ┟───┘       ┟───┘            ┟───┘
//  ┃ introSnd[A] ┞───┐       ┞───┐ elimSnd[A] ┃
//  ┃             ╎One│       ╎One│            ┃
//  ┃             ┟───┘       ┟───┘            ┃
//  ┗━━━━━━━━━━━━━┛           ┗━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">introFst</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">One</span><span> |*| </span><span class="type-name">A</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">introSnd</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">One</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">elimFst</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">One</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">elimSnd</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">One</span><span>) -⚬ </span><span class="type-name">A</span></code></pre>
        <p>Soon we are going to see useful cases of adding and removing <code>One</code>s.</p>
        <p>Since there is no flow of information through <code>One</code>, there is also <em>no causal dependency through <code>One</code>-typed ports.</em>
        This means, for example, that in</p>
        <pre><code>┏━━━━━━━━━┯━━━━━━━━━━━━━┯━━━━━━━━━━━┓
┃         ╎             ├───┐       ┞───┐
┃         ╎             ╎One│   g   ╎ B │
┃         ╎             ├───┘       ┟───┘
┃    f    ╎ introFst[C] ├╌╌╌╌╌╌╌╌╌╌╌┨
┞───┐     ├───┐         ├───┐       ┞───┐
╎ A │     ╎ C │         ╎ C │ id[C] ╎ C │
┟───┘     ├───┘         ├───┘       ┟───┘
┗━━━━━━━━━┷━━━━━━━━━━━━━┷━━━━━━━━━━━┛</code></pre>
        <p>there is no causal dependence of <code>g</code> on anything in <code>f</code> going through the <code>introFst[C]</code> component.</p>
        
        <h2 id="signals" class="section"><a class="anchor-link left" href="#signals"><i class="icofont-laika">&#xef71;</i></a>Signals</h2>
        <p>By a signal we mean a notification that some event has occurred. The signal itself carries no information about the
        event, though, it only signals that the event has occurred.</p>
        <p>There are 4 types of signals, differing in the direction of travel and/or whether they can be dismissed:</p>
        <table>
          <thead>
            <tr>
              <th></th>
              <th>Non-dismissible</th>
              <th>Dismissible</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Positive (left-to-right)</td>
              <td><code>Done</code></td>
              <td><code>Ping</code></td>
            </tr>
            <tr>
              <td>Negative (right-to-left)</td>
              <td><code>Need</code></td>
              <td><code>Pong</code></td>
            </tr>
          </tbody>
        </table>
        <ul>
          <li>Positive signals (<code>Done</code>, <code>Ping</code>) travel in the direction of <code>-⚬</code>.</li>
          <li>Negative signals (<code>Need</code>, <code>Pong</code>) travel in the direction opposite to <code>-⚬</code>.</li>
        </ul>
        <p>Signals are useful for creating causal dependencies: one component might wait for a signal from another component
        before proceeding with further processing. For example, the signal might signal completion of a request and further
        processing might be accepting another request, effectively sequencing request processing.</p>
        <p>For someone used to <code>Future</code> and <code>Promise</code>, it might be helpful, <em>despite important differences,</em> to initially view</p>
        <ul>
          <li><code>Done</code> and <code>Ping</code> as <code>Future[Unit]</code>,</li>
          <li><code>Need</code> and <code>Pong</code> as <code>Promise[Unit]</code>.</li>
        </ul>
        
        <h3 id="immediate-signals" class="section"><a class="anchor-link left" href="#immediate-signals"><i class="icofont-laika">&#xef71;</i></a>Immediate signals</h3>
        <p>There are primitive components that fire a signal immediately. More precisely, as soon as it is certain that
        they will be executed (but we haven&#39;t seen any conditional operators yet). These are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━┓         ┏━━━━━━━━━━━━━━┓     ┏━━━━━━━━━━━━┓         ┏━━━━━━━━━━━━━━┓
//  ┃            ┞────┐    ┞────┐         ┃     ┃            ┞────┐    ┞────┐         ┃
//  ┃    done    ╎Done│    ╎Need│  need   ┃     ┃    ping    ╎Ping│    ╎Pong│  pong   ┃
//  ┃            ┟────┘    ┟────┘         ┃     ┃            ┟────┘    ┟────┘         ┃
//  ┗━━━━━━━━━━━━┛         ┗━━━━━━━━━━━━━━┛     ┗━━━━━━━━━━━━┛         ┗━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">done</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">need</span><span>: </span><span class="type-name">Need</span><span> -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">ping</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Ping</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">pong</span><span>: </span><span class="type-name">Pong</span><span> -⚬ </span><span class="type-name">One</span></code></pre>
        
        <h3 id="non-dismissible-signals" class="section"><a class="anchor-link left" href="#non-dismissible-signals"><i class="icofont-laika">&#xef71;</i></a>Non-dismissible signals</h3>
        <p><code>Done</code> and <code>Need</code> are non-dismissible: once created, they have to be used
        (typically as a trigger for another action).
        In this way, an incoming non-dismissible signal, whether <code>Done</code> incoming from the left
        or <code>Need</code> incoming from the right, is a liability.</p>
        <p><code>Done</code> and <code>Need</code> are used to transfer the obligation to wait for a running task.
        Ignoring such a signal would mean losing track of the running task, which is a resource leak,
        and thus is prohibited.</p>
        
        <h3 id="dismissible-signals" class="section"><a class="anchor-link left" href="#dismissible-signals"><i class="icofont-laika">&#xef71;</i></a>Dismissible signals</h3>
        <p><code>Ping</code> and <code>Pong</code> are used to signal completion of a task, but do not transfer the obligation
        to await that task, because someone else is already keeping track of it.</p>
        <p>The receiver of <code>Ping</code> or <code>Pong</code> may ignore the signal using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">dismissPing</span><span>: </span><span class="type-name">Ping</span><span> -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">dismissPong</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Pong</span></code></pre>
        
        <h3 id="forking-and-joining-signals" class="section"><a class="anchor-link left" href="#forking-and-joining-signals"><i class="icofont-laika">&#xef71;</i></a>Forking and joining signals</h3>
        <p><em>Forking</em> a signal means that as soon as the signal arrives, two new signals are fired.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
//  ┃   fork   ┞────┐    ┃ forkPing ┞────┐    ┞────┐     ┃         ┞────┐     ┃
//  ┃          ╎Done│    ┃          ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┞────┐     ┟────┘    ┞────┐     ┟────┘    ┟────┘     ┞────┐    ┟────┘     ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃ forkNeed ╎Need│    ┃ forkPong ╎Pong│
//  ┟────┘     ┞────┐    ┟────┘     ┞────┐    ┞────┐     ┟────┘    ┞────┐     ┟────┘
//  ┃          ╎Done│    ┃          ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┃          ┟────┘    ┃          ┟────┘    ┟────┘     ┃         ┟────┘     ┃
//  ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">fork</span><span>     : </span><span class="type-name">Done</span><span> -⚬ (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkPing</span><span> : </span><span class="type-name">Ping</span><span> -⚬ (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkNeed</span><span> : (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>) -⚬ </span><span class="type-name">Need</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkPong</span><span> : (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>) -⚬ </span><span class="type-name">Pong</span></code></pre>
        <p>Remember that <code>Need</code> and <code>Pong</code> travel from right to left, so <code>forkNeed</code> and <code>forkPong</code> have
        one signal coming in from the right and two signals coming out on the left.</p>
        <p><em>Joining</em> two signals means to fire a signal as soon as both signals arrive.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
//  ┞────┐     ┃         ┞────┐     ┃         ┃ joinNeed ┞────┐    ┃ joinPong ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃          ╎Need│    ┃          ╎Pong│
//  ┟────┘     ┞────┐    ┟────┘     ┞────┐    ┞────┐     ┟────┘    ┞────┐     ┟────┘
//  ┃   join   ╎Done│    ┃ joinPing ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┞────┐     ┟────┘    ┞────┐     ┟────┘    ┟────┘     ┞────┐    ┟────┘     ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃          ╎Need│    ┃          ╎Pong│
//  ┟────┘     ┃         ┟────┘     ┃         ┃          ┟────┘    ┃          ┟────┘
//  ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">join</span><span>     : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>) -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinPing</span><span> : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>) -⚬ </span><span class="type-name">Ping</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinNeed</span><span> : </span><span class="type-name">Need</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinPong</span><span> : </span><span class="type-name">Pong</span><span> -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>)</span></code></pre>
        <p>Again, since <code>Need</code> and <code>Pong</code> travel from right to left, <code>joinNeed</code> and <code>joinPong</code> have
        two signals coming in from the right and one signal coming out on the left</p>
        
        <h3 id="inverting-signals" class="section"><a class="anchor-link left" href="#inverting-signals"><i class="icofont-laika">&#xef71;</i></a>Inverting signals</h3>
        <p>There are primitives to invert the direction of a signal.</p>
        <p>A signal traveling to the left (<code>Need</code>, <code>Pong</code>) can be changed to the respective signal traveling to the right (<code>Done</code>, <code>Ping</code>).</p>
        <p>A signal traveling to the right (<code>Done</code>, <code>Ping</code>) can be changed to the respective signal traveling to the left (<code>Need</code>, <code>Pong</code>).</p>
        <pre><code class="nohighlight"><span class="comment">//  lInvertSignal           rInvertSignal      lInvertPongPing        rInvertPingPong
//  ┏━━━━━━━━━━┓             ┏━━━━━━━━━━┓      ┏━━━━━━━━━━┓             ┏━━━━━━━━━━┓
//  ┃          ┃             ┃          ┃      ┃          ┃             ┃          ┃
//  ┃          ┞────┐        ┞────┐     ┃      ┃          ┞────┐        ┞────┐     ┃
//  ┃       ┌┄┄╎Need│←┄    ┄→╎Done│┄┄┐  ┃      ┃       ┌┄┄╎Pong│←┄    ┄→╎Ping│┄┄┐  ┃
//  ┃       ┆  ┟────┘        ┟────┘  ┆  ┃      ┃       ┆  ┟────┘        ┟────┘  ┆  ┃
//  ┃       ┆  ┃             ┃       ┆  ┃      ┃       ┆  ┃             ┃       ┆  ┃
//  ┃       ┆  ┞────┐        ┞────┐  ┆  ┃      ┃       ┆  ┞────┐        ┞────┐  ┆  ┃
//  ┃       └┄→╎Done│┄→    ←┄╎Need│←┄┘  ┃      ┃       └┄→╎Ping│┄→    ←┄╎Pong│←┄┘  ┃
//  ┃          ┟────┘        ┟────┘     ┃      ┃          ┟────┘        ┟────┘     ┃
//  ┗━━━━━━━━━━┛             ┗━━━━━━━━━━┛      ┗━━━━━━━━━━┛             ┗━━━━━━━━━━┛
</span><span>

</span><span class="keyword">def</span><span> </span><span class="declaration-name">lInvertSignal</span><span>   : </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">rInvertSignal</span><span>   : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Need</span><span>) -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">rInvertPingPong</span><span> : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Pong</span><span>) -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">lInvertPongPing</span><span> : </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Ping</span><span>)</span></code></pre>
        <p>Using these, we can always move a signal to the other side of the <code>-⚬</code> arrow while changing its direction.
        For example, given</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┓
 *  ┞────┐       ┃
 *  ╎Done│       ┃
 *  ┟────┘   f   ┃
 *  ┞────┐       ┞────┐
 *  ╎ A  │       ╎ B  │
 *  ┟────┘       ┟────┘
 *  ┗━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">f</span><span>: (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">B</span><span> =
  ???</span></code></pre>
        <p>we can always obtain</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━┓
 *  ┃             ┞────┐
 *  ┃             ╎Need│
 *  ┃       g     ┟────┘
 *  ┞────┐        ┞────┐
 *  ╎ A  │        ╎ B  │
 *  ┟────┘        ┟────┘
 *  ┗━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">B</span><span>) =
  ???</span></code></pre>
        <p>roughly like this</p>
        <pre><code>┏━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
┃ lInvertSignal ├────┐ id[Need] ┞────┐
┃          ┌┄┄┄┄╎Need│←┄┄┄┄┄┄┄┄┄╎Need│←┄
┃          ┆    ├────┘          ┟────┘
┃          ┆    ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
┃          ┆    ├────┐          ┃
┃          └┄┄┄→╎Done│          ┃
┃               ├────┘          ┃
┠╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤       f       ┃
┞───┐           ├───┐           ┞───┐
╎ A │   id[A]   ╎ A │           ╎ B │
┟───┘           ├───┘           ┟───┘
┗━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛</code></pre>
        <p>and precisely (including all the necessary glue) like this</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
 *  ┃             ╎ lInvertSignal ├────┐         ├────┐          ┞────┐
 *  ┃ introFst[A] ├───┐           ╎Need│         ╎Need│ id[Need] ╎Need│
 *  ┃             ╎One│           ╎ ⊗  │         ├────┘          ┟────┘
 *  ┃             ├───┘           ╎Done│         ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
 *  ┃             ╎               ├────┘         ├────┐          ┃
 *  ┃             ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤    assocLR   ╎Done│          ┃
 *  ┞───┐         ├───┐           ├───┐          ╎ ⊗  │    f     ┞───┐
 *  ╎ A │         ╎ A │   id[A]   ╎ A │          ╎ A  │          ╎ B │
 *  ┟───┘         ├───┘           ├───┘          ├────┘          ┟───┘
 *  ┗━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">B</span><span>) =
  </span><span class="identifier">introFst</span><span>[</span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">lInvertSignal</span><span>, </span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>]) &gt; </span><span class="identifier">assocLR</span><span> &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">Need</span><span>], </span><span class="identifier">f</span><span>)</span></code></pre>
        
        <h2 id="either" class="section"><a class="anchor-link left" href="#either"><i class="icofont-laika">&#xef71;</i></a>Either (⊕)</h2>
        <p>Type <code>A ⊕ B</code> (in code we use <code>A |+| B</code> for easier typing and better intelligibility) means either <code>A</code> or <code>B</code> (but
        not both), and which one it is going to be is decided by the component on the left.
        In other words, a component that has <code>A ⊕ B</code> as an out-port decides whether the interaction will continue as <code>A</code> or
        as <code>B</code>, while a component that has <code>A ⊕ B</code> as an in-port has to be able to handle either case.
        That is, the decision flows from left to right (the positive direction).</p>
        <p>Primitives for making the decision (introducing <code>|+|</code>) are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━┓               ┏━━━━━━━━━━━━━━┓
//  ┞───┐          ┞───┐           ┃              ┞───┐
//  ╎ A │          ╎ A │           ┃ injectR[A,B] ╎ A │
//  ┟───┘          ╎ ⊕ │           ┞───┐          ╎ ⊕ │
//  ┃ injectL[A,B] ╎ B │           ╎ B │          ╎ B │
//  ┃              ┟───┘           ┟───┘          ┟───┘
//  ┗━━━━━━━━━━━━━━┛               ┗━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">injectL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">injectR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">B</span><span> -⚬ (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>)</span></code></pre>
        <p>These are analogous to Scala&#39;s <code>Left(a)</code> and <code>Right(b)</code> constructors of <code>Either[A, B]</code>.</p>
        <p>The primitive for handling the actually chosen side (eliminating <code>|+|</code>) is</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/**  ┏━━━━━━━━━━━━━━┓
  *  ┞───┬──────────┨
  *  ╎ A ╷    f     ┞───┐
  *  ╎ ⊕ ├──────────╎ C │
  *  ╎ B ╵    g     ┟───┘
  *  ┟───┴──────────┨
  *  ┗━━━━━━━━━━━━━━┛
  */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">either</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>): (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span></code></pre>
        <p>It is analogous to Scala&#39;s <code>Either#fold(f: A =&gt; C, g: B =&gt; C): C</code>.</p>
        <p>Once it is decided which case it is going to be, the corresponding component, <code>f</code> or <code>g</code>, is executed:</p>
        <pre><code>  ┏━━━━━━━━━━━━━━┓                          ┏━━━━━━━━━━━━━━┓
  ┞───┬────────╮ ┃                          ┞───┐          ┃
  ╎*A*╎   f    ╰─╀───┐                      ╎ A │     ╭────╀───┐
  ╎ ⊕ ├─────╮    ╎ C │                      ╎ ⊕ ├─────╯    ╎ C │
  ╎ B │     ╰────╁───┘                      ╎*B*╎   g    ╭─╁───┘
  ┟───┘          ┃                          ┟───┴────────╯ ┃
  ┗━━━━━━━━━━━━━━┛                          ┗━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Note, however, that in <code>either(f &gt; h, g &gt; h)</code>, the common part, <code>h</code>, is certain to be executed in either case,
        and thus may start executing even before the <code>|+|</code> is decided. Indeed, it must hold that</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span> &gt; </span><span class="identifier">h</span><span>, </span><span class="identifier">g</span><span> &gt; </span><span class="identifier">h</span><span>) = </span><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>) &gt; </span><span class="identifier">h</span></code></pre>
        
        <h2 id="choice" class="section"><a class="anchor-link left" href="#choice"><i class="icofont-laika">&#xef71;</i></a>Choice (&amp;)</h2>
        <p>Type <code>A &amp; B</code> (we use <code>A |&amp;| B</code> in code to avoid confusion with the bitwise and operator in Scala, and for consistency
        with <code>|*|</code> and <code>|+|</code>) means an <em>exclusive</em> choice between <code>A</code> and <code>B</code>.
        The component to the right of <code>A &amp; B</code>, i.e. the one that has <code>A &amp; B</code> as an in-port, gets to choose whether
        the interaction with the component to the left will continue as <code>A</code> or as <code>B</code>.
        The component to the left of <code>A &amp; B</code>, i.e. the one that has <code>A &amp; B</code> as an out-port, has to be able to provide
        either of them (but not both of them simultaneously).
        That is, the decision flows from right to left (the negative direction).</p>
        <p>Primitives for choosing one of the options (eliminating <code>|&amp;|</code>) are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━━━┓               ┏━━━━━━━━━━━━━━━━━━┓
//  ┞───┐              ┞───┐           ┞───┐              ┃
//  ╎ A │              ╎ A │           ╎ A │              ┃
//  ╎ &amp; │ chooseL[A,B] ┟───┘           ╎ &amp; │ chooseR[A,B] ┞───┐
//  ╎ B │              ┃               ╎ B │              ╎ B │
//  ┟───┘              ┃               ┟───┘              ┟───┘
//  ┗━━━━━━━━━━━━━━━━━━┛               ┗━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">chooseL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">chooseR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">B</span></code></pre>
        <p>They are somewhat analogous to <code>_1</code>, <code>_2</code> methods on Scala&#39;s 2-tuple, except as if by using <code>_1</code> you give up the chance
        to ever access <code>_2</code>, and vice versa.</p>
        <p>The primitive for offering a choice (introducing <code>|&amp;|</code>) is</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/**  ┏━━━━━━━━━━━━━━┓
  *  ┃   ┌──────────╀───┐
  *  ┞───┤    f     ╷ B │
  *  ╎ A ├──────────┤ &amp; │
  *  ┟───┤    g     ╵ C │
  *  ┃   └──────────┟───┘
  *  ┗━━━━━━━━━━━━━━┛
  */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">choice</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>)</span></code></pre>
        <p>Once the choice is made from the right, the corresponding component, <code>f</code> or <code>g</code>, is executed:</p>
        <pre><code>  ┏━━━━━━━━━━━━━━┓                      ┏━━━━━━━━━━━━━━┓
  ┃     ╭────────╀───┐                  ┃              ┞───┐
  ┞───┬─╯   f    ╎*B*│                  ┞───┬─────╮    ╎ B │
  ╎ A ╎    ╭─────┤ &amp; │                  ╎ A ╎     ╰────┤ &amp; │
  ┟───┴────╯     │ C │                  ┟───┴─╮   g    │*C*│
  ┃              ┟───┘                  ┃     ╰────────╁───┘
  ┗━━━━━━━━━━━━━━┛                      ┗━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Note, however, that in <code>choice(h &gt; f, h &gt; g)</code>, the common part, <code>h</code>, is certain to be executed in either case,
        and thus may start executing even before the <code>|&amp;|</code> is decided. Indeed, it must hold that</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">choice</span><span>(</span><span class="identifier">h</span><span> &gt; </span><span class="identifier">f</span><span>, </span><span class="identifier">h</span><span> &gt; </span><span class="identifier">g</span><span>) = </span><span class="identifier">h</span><span> &gt; </span><span class="identifier">choice</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>)</span></code></pre>
        
        <h2 id="distributivity-of-over" class="section"><a class="anchor-link left" href="#distributivity-of-over"><i class="icofont-laika">&#xef71;</i></a>Distributivity of ⊗ over ⊕</h2>
        <p>The tensor product ⊗ distributes over ⊕:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━┓                        ┏━━━━━━━━━━━━━━━━┓
//  ┞─┐              ┞───┐                    ┞─┐              ┞───┐
//  ╎A│              ╎⎛A⎞│                    ╎A│              ╎⎛A⎞│
//  ┟─┘              ╎⎜⊗⎟│                    ╎⊕│              ╎⎜⊗⎟│
//  ┃                ╎⎝B⎠│                    ╎B│              ╎⎝C⎠│
//  ┞─┐ distributeL  ╎ ⊕ │                    ┟─┘ distributeR  ╎ ⊕ │
//  ╎B│              ╎⎛A⎞│                    ┃                ╎⎛B⎞│
//  ╎⊕│              ╎⎜⊗⎟│                    ┞─┐              ╎⎜⊗⎟│
//  ╎C│              ╎⎝C⎠│                    ╎C│              ╎⎝C⎠│
//  ┟─┘              ┟───┘                    ┟─┘              ┟───┘
//  ┗━━━━━━━━━━━━━━━━┛                        ┗━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">distributeL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |+| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">distributeR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |+| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>))</span></code></pre>
        <p>These are primitives (actually, one of them is sufficient thanks to symmetry of ⊗).
        Note that arrows in the opposite direction need not be primitives, as they are always available:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">factorL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |+| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">either</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">injectL</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">injectR</span><span>))

</span><span class="keyword">def</span><span> </span><span class="declaration-name">factorR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |+| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">either</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">injectL</span><span>, </span><span class="identifier">id</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">injectR</span><span>, </span><span class="identifier">id</span><span>))</span></code></pre>
        
        <h2 id="co-distributivity-of-over" class="section"><a class="anchor-link left" href="#co-distributivity-of-over"><i class="icofont-laika">&#xef71;</i></a>Co-distributivity of ⊗ over &amp;</h2>
        <p>The tensor product ⊗ distributes over &amp; as well, only in the opposite (right-to-left) direction.
        This is consistent with the choice being made on the right of <code>A |&amp;| B</code> and being propagated to the left.
        It is therefore helpful to read the following components from right to left to see how one out-port is being distributed
        over the choice in the other out-port.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━━━━┓                        ┏━━━━━━━━━━━━━━━━━━━┓
//  ┞───┐               ┞─┐                      ┞───┐               ┞─┐
//  ╎⎛A⎞│               ╎A│                      ╎⎛A⎞│               ╎A│
//  ╎⎜⊗⎟│               ┟─┘                      ╎⎜⊗⎟│               ╎&amp;│
//  ╎⎝B⎠│               ┃                        ╎⎝C⎠│               ╎B│
//  ╎ &amp; │ coDistributeL ┞─┐                      ╎ &amp; │ coDistributeR ┟─┘
//  ╎⎛A⎞│               ╎B│                      ╎⎛B⎞│               ┃
//  ╎⎜⊗⎟│               ╎&amp;│                      ╎⎜⊗⎟│               ┞─┐
//  ╎⎝C⎠│               ╎C│                      ╎⎝C⎠│               ╎C│
//  ┟───┘               ┟─┘                      ┟───┘               ┟─┘
//  ┗━━━━━━━━━━━━━━━━━━━┛                        ┗━━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">coDistributeL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |&amp;| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">coDistributeR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |&amp;| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>)</span></code></pre>
        <p>The intuition behind <code>coDistributeL</code> above is this: Only after the choice between <code>B</code> and <code>C</code> is made (from the right)
        is it decided how the <code>A</code> on the other out-port is produced, namely, whether it is the <code>A</code> from <code>A ⊗ B</code> or the <code>A</code> from
        <code>A ⊗ C</code>.</p>
        <p>At least one of these needs to be a primitive (the other one can be obtained thanks to symmetry of ⊗).
        Note that arrows in the opposite direction need not be primitives, as they are always available:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">coFactorL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |&amp;| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">choice</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">chooseL</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">chooseR</span><span>))

</span><span class="keyword">def</span><span> </span><span class="declaration-name">coFactorR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |&amp;| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">choice</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">chooseL</span><span>, </span><span class="identifier">id</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">chooseR</span><span>, </span><span class="identifier">id</span><span>))</span></code></pre>
        
        <h2 id="linearity-and-point-free-style" class="section"><a class="anchor-link left" href="#linearity-and-point-free-style"><i class="icofont-laika">&#xef71;</i></a>Linearity and point-free style</h2>
        <p>When composing components into larger components, it cannot happen that somewhere inside a composite component
        some ports remain unconnected. The way composition works, all ports of a constituent component that the composition
        operator does not connect to other ports become ports of the composite component.
        It also cannot happen that some port is connected twice.
        The property of each port being connected exactly once is called <em>linearity</em>—data and resources flow through the system
        in a linear fashion, without being duplicated or ignored (except via explicit operators for precisely that purpose).</p>
        <p>Notice that building Libretto components is like composing Scala functions in <em>point-free style.</em>
        For a moment, forget the differences between <code>-⚬</code> and <code>=&gt;</code> and view in-ports as function inputs.
        In Libretto, we define the (linear) function without ever having access to the inputs as Scala values.
        Indeed, user code will never have access to values of types like <code>One</code>, <code>Done</code>, <code>Need</code>, <code>A |*| B</code>, <code>A |+| B</code>, <code>A &amp; B</code>
        or others that we will encounter later. If it did, it would break linearity,
        because Scala functions can freely ignore or duplicate (references to) values.</p>
        <p>Moreover, not only are values of the above types not accessible to a user, there need not be any values of these
        types at all. In fact, they are all uninhabited types in the proof-of-concept implementation. This should not be
        surprising when you realize that Libretto&#39;s linear functions are mere blueprints. What then flows in a running system
        when the blueprint is executed need not be values of the auxiliary formal types used in blueprints.</p>
        
        <h2 id="recursion" class="section"><a class="anchor-link left" href="#recursion"><i class="icofont-laika">&#xef71;</i></a>Recursion</h2>
        
        <h3 id="recursive-types" class="section"><a class="anchor-link left" href="#recursive-types"><i class="icofont-laika">&#xef71;</i></a>Recursive types</h3>
        <p>To define recursive port-types, there is <code>Rec[F[_]]</code> type constructor provided as a primitive:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]

</span><span class="comment">/** Hides one level of a recursive type definition. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">pack</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">F</span><span>[</span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]] -⚬ </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]

</span><span class="comment">/** Unpacks one level of a recursive type definition. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unpack</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>] -⚬ </span><span class="type-name">F</span><span>[</span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]]</span></code></pre>
        <p>(Note that <code>Rec</code> is analogous to the <a href="https://hackage.haskell.org/package/data-fix-0.3.1/docs/Data-Fix.html">Fix</a> type
        constructor.)</p>
        <p>You can roughly think of the abstract type <code>Rec[F[_]]</code> as if it was a recursive type alias <code>type Rec[F[_]] = F[Rec[F]]</code>.
        We just have to do the substitution in either direction explicitly via <code>pack</code> and <code>unpack</code>.</p>
        <p>As an example, let&#39;s define a <code>List</code> type:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//         +-------- element type
//         |    +--- marks occurrences of recursive substructure(s), in this case the tail sub-list
//         |    |     +-- nil     +-- cons
//         |    |     | head --+  |   +-- tail
//         |    |     |        |  |   |
//         V    V     V        V  V   V
</span><span class="keyword">type</span><span> </span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">Self</span><span>] = </span><span class="type-name">One</span><span> |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">Self</span><span>)
</span><span class="keyword">type</span><span> </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">Rec</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]] </span><span class="comment">// the * is kind-projector syntax for type lambdas,</span></code></pre>
        <p>and the <code>nil</code> and <code>cons</code> constructors:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">List</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">nil</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="identifier">injectL</span><span> &gt; </span><span class="identifier">pack</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]]

  </span><span class="comment">//     head --+       +-- tail
</span><span>  </span><span class="comment">//            |       |
</span><span>  </span><span class="comment">//            V       V
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">cons</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="identifier">injectR</span><span> &gt; </span><span class="identifier">pack</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]]
}</span></code></pre>
        <p>Notes:</p>
        <ul>
          <li>Such a <code>List</code> may be produced gradually. For example, one may use the <code>cons</code> constructor where the tail is not yet
          known to be either empty or non-empty. Consequently, the head of a list can already be accessed and consumed (e.g.
          by the <code>map</code> function defined below) while the tail is still being constructed.
          This is different from <code>scala.List</code> where in <code>val xs = head :: tail</code> the <code>tail</code> is fully constructed before <code>xs</code>
          is constructed and its head made accessible for further processing.</li>
          <li>Consequently, <code>List</code>s may be infinite and it is not a problem if the elements are consumed at a faster rate than
          they are produced.</li>
          <li>Note that unlike infinite lazy lists in Haskell, the construction of further elements is driven by the <code>List</code>
          producer, not by the <code>List</code> consumer.</li>
        </ul>
        
        <h3 id="recursive-functions" class="section"><a class="anchor-link left" href="#recursive-functions"><i class="icofont-laika">&#xef71;</i></a>Recursive functions</h3>
        <p>To work with recursive structures we need recursive functions.</p>
        <p>The general recipe for handling a recursive type <code>Rec[F]</code> is</p>
        <ol class="arabic">
          <li>&quot;Pretend&quot; we already know how to handle the nested <code>Rec[F]</code> substructure(s).</li>
          <li>Unpack one level of the recursive definition to obtain <code>F[Rec[F]</code>.</li>
          <li>Write code to handle <code>F[Rec[F]]</code>, using the made up linear function to handle nested occurrences of <code>Rec[F]</code>.</li>
        </ol>
        <p>The &quot;pretending&quot; is done by taking a linear function as an argument. More concretely, instead of constructing a linear
        function <code>Rec[F] -⚬ B</code> directly, we write a Scala function <code>(Rec[F] -⚬ B) =&gt; (Rec[F] -⚬ B)</code> that constructs the desired
        linear function given a linear function of the same signature that it can use to handle substructures. Such Scala
        function can then be passed to the primitive <code>rec</code> function that &quot;ties the loop&quot; and produces the desired linear
        function <code>Rec[F] -⚬ B</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rec</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>) =&gt; (</span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>)): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span></code></pre>
        <p>As an example, let&#39;s define a linear function that applies a given linear function to each element of a <code>List</code>
        (defined above).</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">List</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>] = {
    </span><span class="comment">//                         +-- pretending we already know how to map the tail
</span><span>    </span><span class="comment">//                         |
</span><span>    </span><span class="comment">//                         V
</span><span>    </span><span class="identifier">rec</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>]] { (</span><span class="identifier">mapTail</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>]) =&gt;
      </span><span class="identifier">unpack</span><span> &gt; </span><span class="identifier">either</span><span>(
        </span><span class="identifier">nil</span><span>[</span><span class="type-name">B</span><span>],
        </span><span class="identifier">par</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">mapTail</span><span>) &gt; </span><span class="identifier">cons</span><span>[</span><span class="type-name">B</span><span>],
      )
    }
  }
}</span></code></pre>
        <p>Notes:</p>
        <ul>
          <li><code>par(f, mapTail)</code> maps the head and the tail of the list concurrently.</li>
          <li>The <code>cons[B]</code> constructor may execute as soon as the input list is known to be non-empty.
          In particular, it does not wait for <code>par(f, mapTail)</code> to finish.</li>
        </ul>
        
        <h2 id="racing" class="section"><a class="anchor-link left" href="#racing"><i class="icofont-laika">&#xef71;</i></a>Racing</h2>
        <p>Libretto provides functions for testing which of two concurrent signals arrived first.</p>
        <p>The two basic racing operations are on dismissible signals, <code>Ping</code> and <code>Pong</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">racePair</span><span>   : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>) -⚬ (</span><span class="type-name">One</span><span> |+| </span><span class="type-name">One</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">selectPair</span><span> : (</span><span class="type-name">One</span><span> |&amp;| </span><span class="type-name">One</span><span>) -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>)</span></code></pre>
        <p>In <code>racePair</code>, the two <code>Ping</code> signals from the in-port race against each other.
        If the first signal wins, the output will be left.
        If the second signal wins, the output will be right.</p>
        <p>In <code>selectPair</code>, the two <code>Pong</code> signals from the <em>out</em>-port race against each other.
        If the first signal wins, left will be chosen from the input.
        If the second signal wins, right will be chosen from the input.</p>
        <p>In both cases, both signals are consumed: the winning one has fired, the slower one is dismissed.</p>
        <p>Only one of these operations needs to be a primitive, the other one is derivable using signal inversions discussed above.</p>
        <p>There are also versions for non-dismissible signals (<code>Done</code> and <code>Need</code>):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">raceDone</span><span>   : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>) -⚬ (</span><span class="type-name">Done</span><span> |+| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">selectNeed</span><span> : (</span><span class="type-name">Need</span><span> |&amp;| </span><span class="type-name">Need</span><span>) -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>)</span></code></pre>
        <p>The main difference is that only the winning signal is consumed by the race.
        The slower signal still has to be awaited at some point, so it is propagated to the other side of <code>-⚬</code>:</p>
        <ul>
          <li>In <code>raceDone</code>, if the first <code>Done</code> signal of the in-port wins, the second one is returned on the left of the <code>|+|</code>
          in the out-port. The case of second signal winning is analogous.</li>
          <li>In <code>selectNeed</code>, if the first <code>Need</code> signal of the <em>out</em>-port wins, the left side of the <code>|&amp;|</code> in the in-port is
          chosen and the second <code>Need</code> signal of the out-port is forwarded to it.</li>
        </ul>
        <p>There are additional library functions for racing built on top of these, provided for convenience.</p>
        
        <h3 id="racing-is-a-source-of-non-determinism" class="section"><a class="anchor-link left" href="#racing-is-a-source-of-non-determinism"><i class="icofont-laika">&#xef71;</i></a>Racing is a source of non-determinism</h3>
        <p>The order of two concurrently occurring events is undefined. The outcome of a racing operation on two concurrent events
        will therefore be non-deterministic. The non-determinism is propagated by proceeding differently for different winners
        of the race.</p>
        
        <h2 id="using-scala-values-and-functions" class="section"><a class="anchor-link left" href="#using-scala-values-and-functions"><i class="icofont-laika">&#xef71;</i></a>Using Scala values and functions</h2>
        <p>Libretto provides means to use <em>immutable</em> Scala values and <em>total</em> Scala functions in Libretto programs.</p>
        <p>The type <code>Val[A]</code> represents a Scala value of type <code>A</code> flowing in the positive direction (i.e. along the <code>-⚬</code>).
        Similarly, the type <code>Neg[A]</code> represents a Scala value of type <code>A</code> flowing in the negative direction
        (i.e. against the <code>-⚬</code>).</p>
        <p>For a first approximation, <code>Val[A]</code> can be thought of as <code>Future[A]</code> and <code>Neg[A]</code> can be thought of as <code>Promise[A]</code>.</p>
        <p>To initially get some Scala values into a Libretto program, we bake them in during assembly using the primitives</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">constVal</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">a</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Done</span><span> -⚬ </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">constNeg</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">a</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Need</span></code></pre>
        <p>Notice the incoming signals, <code>Done</code> and <code>Need</code>, respectively. Given that signals cannot be ignored, the responsibility
        to handle a signal is transformed into a responsibility to handle a Scala value. This is OK, because Scala values cannot
        be completely ignored, either. Doing so would mean to lose track of an ongoing potentially expensive computation and
        thus a resource leak.</p>
        <p>However, the particular value inside <code>Val</code> or <code>Neg</code> can be ignored; we just have to keep the liability to await the
        computation. For this purpose, there are primitives to convert Scala values into signals:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">neglect</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">inflate</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">Need</span><span> -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>On the other hand, values can be duplicated, using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">dup</span><span>   [</span><span class="type-name">A</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">dupNeg</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>Because of this ability to duplicate values, it is preferable to use only <em>immutable</em> values.</p>
        <p>To apply a Scala function to a Scala value inside a Libretto program, we can use one of the primitives</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span>       </span><span class="declaration-name">mapVal</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">contramapNeg</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>] -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>Note that the Scala functions used must be <em>total,</em> that is they must always terminate and never throw an exception.</p>
        <p>It is preferable that the used functions also be <em>pure,</em> but benign side-effects are OK. Just note that it is undefined
        on which thread the function will execute, and that it may as well not execute at all.</p>
        <p>We can convert between Scala pairs and Libretto concurrent pairs using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span>   </span><span class="declaration-name">liftPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Val</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unliftPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>]) -⚬ </span><span class="type-name">Val</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]

</span><span class="keyword">def</span><span>   </span><span class="declaration-name">liftNegPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Neg</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)] -⚬ (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unliftNegPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>]) -⚬ </span><span class="type-name">Neg</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]</span></code></pre>
        <p>We can lift a decision made by Scala code into Libretto via</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">liftEither</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">Either</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |+| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>])</span></code></pre>
        <p>Just like signals, the direction of Scala values can be inverted:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━┓                   ┏━━━━━━━━━━━━━━━┓
//  ┃  promise[A]   ┃                   ┃  fulfill[A]   ┃
//  ┃               ┞──────┐            ┞──────┐        ┃
//  ┃            ┌┄┄╎Neg[A]│←┄        ┄→╎Val[A]│┄┄┐     ┃
//  ┃            ┆  ┟──────┘            ┟──────┘  ┆     ┃
//  ┃            ┆  ┃                   ┃         ┆     ┃
//  ┃            ┆  ┞──────┐            ┞──────┐  ┆     ┃
//  ┃            └┄→╎Val[A]│┄→        ←┄╎Neg[A]│←┄┘     ┃
//  ┃               ┟──────┘            ┟──────┘        ┃
//  ┗━━━━━━━━━━━━━━━┛                   ┗━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">promise</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">fulfill</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">One</span></code></pre>
        
        <h2 id="equality-of-libretto-programs" class="section"><a class="anchor-link left" href="#equality-of-libretto-programs"><i class="icofont-laika">&#xef71;</i></a>Equality of Libretto programs</h2>
        <p>There are equations (laws) that hold about Libretto arrows, such as</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">h</span><span>: </span><span class="type-name">C</span><span> -⚬ </span><span class="type-name">D</span><span>

</span><span class="comment">// then
</span><span>
(</span><span class="identifier">f</span><span> &gt; </span><span class="identifier">g</span><span>) &gt; </span><span class="identifier">h</span><span> = </span><span class="identifier">f</span><span> &gt; (</span><span class="identifier">g</span><span> &gt; </span><span class="identifier">h</span><span>)

</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">f</span><span> = </span><span class="identifier">f</span><span> = </span><span class="identifier">f</span><span> &gt; </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>]) = </span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>]</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>

</span><span class="comment">// then
</span><span class="identifier">injectL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] &gt; </span><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>) = </span><span class="identifier">f</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>

</span><span class="comment">// then
</span><span class="identifier">mapVal</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>) &gt; </span><span class="identifier">neglect</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">neglect</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>and many more.</p>
        <p><em>But what does it mean for two Libretto programs to be equal?</em></p>
        <p>Obviously, the sides of the equations above have different source code, so they are not equal at the source code level.</p>
        <p><em>We say that two Libretto programs are equal if their causal dependency graphs are equivalent&lt;sup&gt;(*)&lt;/sup&gt;.</em></p>
        <p>&lt;sup&gt;(*)&lt;/sup&gt; For now let&#39;s settle for some intuitive understanding of <em>causal dependency graphs</em> and a suitable
        equivalence on them. Precise definition is left for further work.</p>
        <p>Note that in the presence of non-determinism arising from concurrency, a single program can have multiple possible
        execution traces. (Again, precise definition of an execution trace is left for further work.)</p>
        <p>A particular implementation of Libretto then determines a probability distribution of the possible execution traces
        of a program.</p>
        <p>Note that it is not required of a Libretto implementation that two equal Libretto programs have the same probability
        distribution of execution traces, only that they have the same set of possible execution traces. In practice this means
        that although two programs are equal, they might exhibit statistically different behaviors.</p>
        <p>Finally, let&#39;s give an example of two programs that look the same on the outside, but are not equal:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓              ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
//  ┞────┐        ╎              ┞────┐         ┞────┐      id[Done]        ┞────┐
//  ╎Done│→┄┄┄┄┐  ╎       ┌┄┄┄┄┄→╎Done│         ╎Done│→┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄→╎Done│
//  ┟────┘     ┆  ├────┐  ┆      ┟────┘         ┟────┘                      ┟────┘
//  ┃    join  ├┄→╎Done│→┄┤ fork ┃         ≠    ┠╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
//  ┞────┐     ┆  ├────┘  ┆      ┞────┐         ┞────┐      id[Done]        ┞────┐
//  ╎Done│→┄┄┄┄┘  ╎       └┄┄┄┄┄→╎Done│         ╎Done│→┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄→╎Done│
//  ┟────┘        ╎              ┟────┘         ┟────┘                      ┟────┘
//  ┗━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛              ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="identifier">join</span><span> &gt; </span><span class="identifier">fork</span><span> ≠ </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">Done</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">Done</span><span>])</span></code></pre>
        <p>In the program on the left, each of the output signals depends on both input signals, whereas in the program on the
        right, each output signal depends only on the respective input signal. Clearly, their causal dependency graphs are
        different, and thus the programs are not equal.</p>

      </main>

    </div>

  </body>
</html>